package com.rustyrazorblade.easycasslab

import com.rustyrazorblade.easycasslab.configuration.TFState
import com.rustyrazorblade.easycasslab.configuration.User
import com.rustyrazorblade.easycasslab.core.YamlDelegate
import com.rustyrazorblade.easycasslab.configuration.Host

import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.module.kotlin.readValue
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper

import com.github.dockerjava.core.DockerClientImpl
import com.github.dockerjava.httpclient5.ApacheDockerHttpClient
import com.github.dockerjava.core.DefaultDockerClientConfig

import org.apache.logging.log4j.kotlin.logger
import org.apache.sshd.client.SshClient
import org.apache.sshd.client.session.ClientSession
import org.apache.sshd.common.keyprovider.KeyIdentityProvider
import org.apache.sshd.common.util.security.SecurityUtils
import org.apache.sshd.scp.client.CloseableScpClient
import org.apache.sshd.scp.client.ScpClientCreator

import java.nio.file.Path
import java.time.Duration
import java.io.File
import java.nio.file.Files

import kotlin.io.path.Path


data class Context(val easycasslabUserDirectory: File) {
    var profilesDir = File(easycasslabUserDirectory, "profiles")

    // TODO allow for other profiles
    var profile = System.getenv("EASY_CASS_LAB_PROFILE") ?: "default"

    var profileDir = File(profilesDir, profile)
    val terraformCacheDir = File(easycasslabUserDirectory, "terraform_cache").also { it.mkdirs() }

    var nettyInitialised = false

    init {
        profileDir.mkdirs()
    }

    val log = logger()

    /**
     * Version is either supplied by the in-repo script,
     * or the version generated by the application plugin
     */
    val version = System.getProperty("easycasslab.version").toInt()
    val appHome = System.getProperty("easycasslab.apphome")
    val packerHome = "$appHome/packer/"
    val cassandraVersionsExtra = File(profileDir, "cassandra_versions")

    /**
     * Please use this for reading and writing yaml to objects
     *
     * Example usage:
     *
     * val state = mapper.readValue<MyStateObject>(json)
     */
    val yaml : ObjectMapper by YamlDelegate()

    // if you need to anything funky with the mapper (settings etc) use this
    fun getJsonMapper() = jacksonObjectMapper()

    private val userConfigFile = File(profileDir, "settings.yaml")

    // this will let us write out the yaml
    val userConfig by lazy {
        if(!userConfigFile.exists()) {
            log.debug { "$userConfigFile not found, going through interactive setup" }
            profilesDir.mkdirs()
            User.createInteractively(this, userConfigFile)
        }

        yaml.readValue<User>(userConfigFile)
    }

    val docker by lazy {
        nettyInitialised = true

        val dockerConfig = DefaultDockerClientConfig.createDefaultConfigBuilder()
                .build()

        val httpClient = ApacheDockerHttpClient.Builder()
                .dockerHost(dockerConfig.dockerHost)
                .sslConfig(dockerConfig.sslConfig)
                .build();
        DockerClientImpl.getInstance(dockerConfig, httpClient)
    }

    val awsCredentialsName = "awscredentials"

    /**
     * Lazily create the AWS config. We might not need it and in the future we might support
     * different cloud providers.
     */
    val awsConfig by lazy {
        val fp = File(profileDir, awsCredentialsName)
        if (!fp.exists()) {
            fp.writeText("""[default]
                |aws_access_key_id=${userConfig.awsAccessKey}
                |aws_secret_access_key=${userConfig.awsSecret}
            """.trimMargin("|"))
        }
        fp
    }

    val cwdPath = System.getProperty("user.dir")

    val tfstate by lazy { TFState.parse(this, File(cwdPath, "terraform.tfstate")) }
    val home = File(System.getProperty("user.home"))

    val keyPairs by lazy {
        val loader = SecurityUtils.getKeyPairResourceParser()
        loader.loadKeyPairs(null, Path( userConfig.sshKeyPath), null)

    }

    val sshClient by lazy {
        val client = SshClient.setUpDefaultClient()
        client.setKeyIdentityProvider(KeyIdentityProvider.wrapKeyPairs(keyPairs))
        client.start()
        client
    }

    val sessions = mutableMapOf<Host, ClientSession>()

    private fun getSession(host: Host): ClientSession {
        return sessions.getOrPut(host) {
            val session = sshClient.connect("ubuntu", host.public, 22)
                .verify(Duration.ofSeconds(60))
                .session
            session.addPublicKeyIdentity(keyPairs.first())
            session.auth().verify()
            session
        }
    }

    fun executeRemotely(host: Host, command: String, output: Boolean = true, secret: Boolean = false) : String {
        // Setup guide: https://github.com/apache/mina-sshd/blob/master/docs/client-setup.md

        // Create the client.
        // We have to register the keys with the client.
        // Client can be used to connect to multiple hosts
        println("Connecting to ${host.alias} ${host.public}")
        val session = getSession(host)
        if (!secret) {
            println("Executing remote command: $command")
        } else {
            println("Executing remote command: [hidden]")
        }
        val tmp = session.executeRemoteCommand(command)
        if (output) {
            println(tmp)
        }
        return tmp
    }

    fun getScpClient(host: Host) : CloseableScpClient {
        val session = getSession(host)
        val creator = ScpClientCreator.instance()
        val client = creator.createScpClient(session)
        return CloseableScpClient.singleSessionInstance(client)
    }

    fun upload(host: Host, local: Path, remote: String) {
        val client = getScpClient(host)
        client.upload(local, remote)
    }

    fun download(host: Host, remote: String, local: Path) {
        val client = getScpClient(host)
        client.download(remote, local)
    }

    fun stop() {
        sshClient.stop()
    }

    companion object {
        /**
         * Used only for testing
         */
        fun testContext() : Context {
            val tmpContentParent = File("test/contexts")
            tmpContentParent.mkdirs()

            val testTempDirectory = Files.createTempDirectory(tmpContentParent.toPath(), "easycasslab")
            // create a default profile
            // generate a fake key
            val user = User("test@rustyrazorblade.com", "us-west-2", "test", "test", "test", "test", "test", "", "")

            val context = Context(testTempDirectory.toFile())
            context.yaml.writeValue(context.userConfigFile, user)
            return context
        }
    }

    fun requireSshKey() {
        if(!File(userConfig.sshKeyPath).exists()) {
            log.error { "SSH key not found at ${userConfig.sshKeyPath}" }
            System.exit(1)
        }
    }

}
