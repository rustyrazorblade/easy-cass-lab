package com.rustyrazorblade.easycasslab

import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import com.fasterxml.jackson.module.kotlin.readValue
import com.google.common.annotations.VisibleForTesting
import com.rustyrazorblade.easycasslab.configuration.Host
import com.rustyrazorblade.easycasslab.configuration.TFState
import com.rustyrazorblade.easycasslab.configuration.User
import com.rustyrazorblade.easycasslab.core.YamlDelegate
import com.rustyrazorblade.easycasslab.output.OutputHandler
import com.rustyrazorblade.easycasslab.providers.ssh.RemoteOperationsService
import com.rustyrazorblade.easycasslab.providers.ssh.SSHConnectionProvider
import com.rustyrazorblade.easycasslab.ssh.Response
import io.github.oshai.kotlinlogging.KotlinLogging
import org.koin.core.component.KoinComponent
import org.koin.core.component.inject
import java.io.File
import java.nio.file.Files
import java.nio.file.Path

data class Context(val easycasslabUserDirectory: File) : KoinComponent {
    var profilesDir = File(easycasslabUserDirectory, "profiles")

    // TODO allow for other profiles
    var profile = System.getenv("EASY_CASS_LAB_PROFILE") ?: "default"

    var profileDir = File(profilesDir, profile)
    val terraformCacheDir = File(easycasslabUserDirectory, "terraform_cache").also { it.mkdirs() }

    init {
        profileDir.mkdirs()
    }

    val log = KotlinLogging.logger {}

    /**
     * Version is either supplied by the in-repo script,
     * or the version generated by the application plugin
     */
    val version = System.getProperty("easycasslab.version")?.toInt() ?: 0
    val appHome = System.getProperty("easycasslab.apphome")
    val packerHome = "$appHome/packer/"
    val cassandraVersionsExtra = File(profileDir, "cassandra_versions")

    /**
     * Please use this for reading and writing yaml to objects
     *
     * Example usage:
     *
     * val state = mapper.readValue<MyStateObject>(json)
     */
    val yaml: ObjectMapper by YamlDelegate()

    // if you need to anything funky with the mapper (settings etc) use this
    fun getJsonMapper() = jacksonObjectMapper()

    private val userConfigFile = File(profileDir, "settings.yaml")

    // this will let us write out the yaml
    val userConfig by lazy {
        if (!userConfigFile.exists()) {
            log.debug { "$userConfigFile not found, going through interactive setup" }
            profilesDir.mkdirs()
            User.createInteractively(this, userConfigFile, outputHandler)
        }

        yaml.readValue<User>(userConfigFile)
    }

    // Docker client has been moved to dependency injection via Koin
    // See DockerClientProvider and DockerModule for the new implementation

    val awsCredentialsName = Constants.AWS.DEFAULT_CREDENTIALS_NAME

    /**
     * Lazily create the AWS config. We might not need it and in the future we might support
     * different cloud providers.
     */
    val awsConfig by lazy {
        val fp = File(profileDir, awsCredentialsName)
        if (!fp.exists()) {
            fp.writeText(
                """[default]
                |aws_access_key_id=${userConfig.awsAccessKey}
                |aws_secret_access_key=${userConfig.awsSecret}
            """.trimMargin("|"),
            )
        }
        fp
    }


    // SSH services are now injected via Koin
    private val sshConnectionProvider: SSHConnectionProvider by inject()
    private val remoteOperationsService: RemoteOperationsService by inject()
    private val outputHandler: OutputHandler by inject()

    val cwdPath = System.getProperty("user.dir")

    val tfstate by lazy { TFState.parse(this, File(cwdPath, "terraform.tfstate")) }
    val home = File(System.getProperty("user.home"))

    /**
     * Returns the version currently set on the remote server.
     * Delegates to RemoteOperationsService.
     *
     * @param host The host to check
     * @param inputVersion The version to use, or "current" to check the symlink
     * @return A Version object containing the path and version component
     */
    fun getRemoteVersion(
        host: Host,
        inputVersion: String = "current",
    ): Version {
        return remoteOperationsService.getRemoteVersion(host, inputVersion)
    }

    /**
     * Execute a command on a remote host.
     * Delegates to RemoteOperationsService for backward compatibility.
     */
    fun executeRemotely(
        host: Host,
        command: String,
        output: Boolean = true,
        secret: Boolean = false,
    ): Response {
        return remoteOperationsService.executeRemotely(host, command, output, secret)
    }

    /**
     * Upload a file to a remote host.
     * Delegates to RemoteOperationsService for backward compatibility.
     */
    fun upload(
        host: Host,
        local: Path,
        remote: String,
    ) {
        return remoteOperationsService.upload(host, local, remote)
    }

    /**
     * Uploads a directory recursively to a remote host.
     * Delegates to RemoteOperationsService for backward compatibility.
     * @param host The target host
     * @param localDir The local directory to upload
     * @param remoteDir The remote directory where files will be uploaded
     */
    fun uploadDirectory(
        host: Host,
        localDir: File,
        remoteDir: String,
    ) {
        return remoteOperationsService.uploadDirectory(host, localDir, remoteDir)
    }

    /**
     * Convenience that uses the file and conf dir of Version to upload.
     * Delegates to RemoteOperationsService for backward compatibility.
     */
    fun uploadDirectory(
        host: Host,
        version: Version,
    ) {
        return remoteOperationsService.uploadDirectory(host, version)
    }

    /**
     * Download a file from a remote host.
     * Delegates to RemoteOperationsService for backward compatibility.
     */
    fun download(
        host: Host,
        remote: String,
        local: Path,
    ) {
        return remoteOperationsService.download(host, remote, local)
    }

    /**
     * Downloads a directory recursively from a remote host.
     * Delegates to RemoteOperationsService for backward compatibility.
     * @param host The source host
     * @param remoteDir The remote directory to download
     * @param localDir The local directory where files will be downloaded
     * @param includeFilters Optional list of patterns to filter files for download (e.g. "jvm*")
     * @param excludeFilters Optional list of patterns to exclude files from download (e.g. "*.bak")
     */
    fun downloadDirectory(
        host: Host,
        remoteDir: String,
        localDir: File,
        includeFilters: List<String> = listOf(),
        excludeFilters: List<String> = listOf(),
    ) {
        return remoteOperationsService.downloadDirectory(host, remoteDir, localDir, includeFilters, excludeFilters)
    }

    /**
     * Stop all SSH connections.
     * Delegates to SSHConnectionProvider.
     */
    fun stop() {
        sshConnectionProvider.stop()
    }

    companion object {
        /**
         * Used only for testing
         */
        @VisibleForTesting
        fun testContext(): Context {
            val tmpContentParent = File("test/contexts")
            tmpContentParent.mkdirs()

            val testTempDirectory = Files.createTempDirectory(tmpContentParent.toPath(), "easycasslab")
            assert(testTempDirectory != null)
            // create a default profile
            // generate a fake key
            val user = User("test@rustyrazorblade.com", "us-west-2", "test", "test", "test", "test", "test", "", "")

            val context = Context(testTempDirectory.toFile())
            context.yaml.writeValue(context.userConfigFile, user)
            return context
        }
    }

    fun requireSshKey() {
        if (!File(userConfig.sshKeyPath).exists()) {
            log.error { "SSH key not found at ${userConfig.sshKeyPath}" }
            System.exit(1)
        }
    }
}
