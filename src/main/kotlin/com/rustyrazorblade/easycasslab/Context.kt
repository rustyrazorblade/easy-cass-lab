package com.rustyrazorblade.easycasslab

import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import com.fasterxml.jackson.module.kotlin.readValue
import com.github.dockerjava.core.DefaultDockerClientConfig
import com.github.dockerjava.core.DockerClientImpl
import com.github.dockerjava.httpclient5.ApacheDockerHttpClient
import com.google.common.annotations.VisibleForTesting
import com.rustyrazorblade.easycasslab.configuration.Host
import com.rustyrazorblade.easycasslab.configuration.TFState
import com.rustyrazorblade.easycasslab.configuration.User
import com.rustyrazorblade.easycasslab.core.YamlDelegate
import com.rustyrazorblade.easycasslab.providers.AWS
import com.rustyrazorblade.easycasslab.providers.aws.Clients
import com.rustyrazorblade.easycasslab.ssh.ConnectionManager
import com.rustyrazorblade.easycasslab.ssh.ISSHClient
import com.rustyrazorblade.easycasslab.ssh.Response
import io.github.oshai.kotlinlogging.KotlinLogging
import java.io.File
import java.nio.file.Files
import java.nio.file.Path

/**
 * Represents a Cassandra version
 *
 * @param path The full path to the Cassandra installation
 */
data class Version(val path: String) {
    /**
     * Gets just the version component from the path
     */
    val version: String = path.substringAfterLast("/")
    val conf: String = "$path/conf"

    val file = File(version)

    companion object {
        /**
         * Create a Version from a version string (e.g. "5.0")
         *
         * @param version The version string (e.g. "5.0")
         * @return A Version instance with the appropriate path
         */
        fun fromString(version: String): Version {
            return Version("/usr/local/cassandra/$version")
        }

        fun fromRemotePath(path: String): Version {
            return Version(path)
        }
    }

    val localDir: Path get() = Path.of(version)
}

data class Context(val easycasslabUserDirectory: File) {
    var profilesDir = File(easycasslabUserDirectory, "profiles")

    // TODO allow for other profiles
    var profile = System.getenv("EASY_CASS_LAB_PROFILE") ?: "default"

    var profileDir = File(profilesDir, profile)
    val terraformCacheDir = File(easycasslabUserDirectory, "terraform_cache").also { it.mkdirs() }

    var nettyInitialised = false

    init {
        profileDir.mkdirs()
    }

    val log = KotlinLogging.logger {}

    /**
     * Version is either supplied by the in-repo script,
     * or the version generated by the application plugin
     */
    val version = System.getProperty("easycasslab.version")?.toInt() ?: 0
    val appHome = System.getProperty("easycasslab.apphome")
    val packerHome = "$appHome/packer/"
    val cassandraVersionsExtra = File(profileDir, "cassandra_versions")

    /**
     * Please use this for reading and writing yaml to objects
     *
     * Example usage:
     *
     * val state = mapper.readValue<MyStateObject>(json)
     */
    val yaml: ObjectMapper by YamlDelegate()

    // if you need to anything funky with the mapper (settings etc) use this
    fun getJsonMapper() = jacksonObjectMapper()

    private val userConfigFile = File(profileDir, "settings.yaml")

    // this will let us write out the yaml
    val userConfig by lazy {
        if (!userConfigFile.exists()) {
            log.debug { "$userConfigFile not found, going through interactive setup" }
            profilesDir.mkdirs()
            User.createInteractively(this, userConfigFile)
        }

        yaml.readValue<User>(userConfigFile)
    }

    val docker by lazy {
        nettyInitialised = true

        val dockerConfig =
            DefaultDockerClientConfig.createDefaultConfigBuilder()
                .build()

        val httpClient =
            ApacheDockerHttpClient.Builder()
                .dockerHost(dockerConfig.dockerHost)
                .sslConfig(dockerConfig.sslConfig)
                .build()
        DockerClientImpl.getInstance(dockerConfig, httpClient)
    }

    val awsCredentialsName = "awscredentials"

    /**
     * Lazily create the AWS config. We might not need it and in the future we might support
     * different cloud providers.
     */
    val awsConfig by lazy {
        val fp = File(profileDir, awsCredentialsName)
        if (!fp.exists()) {
            fp.writeText(
                """[default]
                |aws_access_key_id=${userConfig.awsAccessKey}
                |aws_secret_access_key=${userConfig.awsSecret}
            """.trimMargin("|"),
            )
        }
        fp
    }

    /**
     * Setting the codebase up to be able to support other cloud providers
     */
    val cloudProvider by lazy {
        val clients = Clients(userConfig)
        AWS(clients)
    }

    val connectionManager by lazy { ConnectionManager(userConfig.sshKeyPath) }

    val cwdPath = System.getProperty("user.dir")

    val tfstate by lazy { TFState.parse(this, File(cwdPath, "terraform.tfstate")) }
    val home = File(System.getProperty("user.home"))

    // Made overridable for testing
    var getConnection: (Host) -> ISSHClient = { host -> connectionManager.getConnection(host) }

    /**
     * Returns the version currently set on the remote server.
     *
     * @param host The host to check
     * @param inputVersion The version to use, or "current" to check the symlink
     * @return A Version object containing the path and version component
     */
    fun getRemoteVersion(
        host: Host,
        inputVersion: String = "current",
    ): Version {
        return if (inputVersion == "current") {
            val path = executeRemotely(host, "readlink -f /usr/local/cassandra/current").text.trim()
            Version(path)
        } else {
            Version.fromString(inputVersion)
        }
    }

    fun executeRemotely(
        host: Host,
        command: String,
        output: Boolean = true,
        secret: Boolean = false,
    ): Response {
        return getConnection(host).executeRemoteCommand(command, output, secret)
    }

    fun upload(
        host: Host,
        local: Path,
        remote: String,
    ) {
        return getConnection(host).uploadFile(local, remote)
    }

    /**
     * Uploads a directory recursively to a remote host.
     * @param host The target host
     * @param localDir The local directory to upload
     * @param remoteDir The remote directory where files will be uploaded
     */
    fun uploadDirectory(
        host: Host,
        localDir: File,
        remoteDir: String,
    ) {
        println("Uploading directory $localDir to $remoteDir")
        return getConnection(host).uploadDirectory(localDir, remoteDir)
    }

    /**
     * Convenience that uses the file and conf dir of Version to upload
     */
    fun uploadDirectory(
        host: Host,
        version: Version,
    ) {
        return uploadDirectory(host, version.file, version.conf)
    }

    fun download(
        host: Host,
        remote: String,
        local: Path,
    ) {
        return getConnection(host).downloadFile(remote, local)
    }

    /**
     * Downloads a directory recursively from a remote host.
     * @param host The source host
     * @param remoteDir The remote directory to download
     * @param localDir The local directory where files will be downloaded
     * @param includeFilters Optional list of patterns to filter files for download (e.g. "jvm*")
     * @param excludeFilters Optional list of patterns to exclude files from download (e.g. "*.bak")
     */
    fun downloadDirectory(
        host: Host,
        remoteDir: String,
        localDir: File,
        includeFilters: List<String> = listOf(),
        excludeFilters: List<String> = listOf(),
    ) {
        return getConnection(host).downloadDirectory(remoteDir, localDir, includeFilters, excludeFilters)
    }

    fun stop() {
        connectionManager.stop()
    }

    companion object {
        /**
         * Used only for testing
         */
        @VisibleForTesting
        fun testContext(): Context {
            val tmpContentParent = File("test/contexts")
            tmpContentParent.mkdirs()

            val testTempDirectory = Files.createTempDirectory(tmpContentParent.toPath(), "easycasslab")
            assert(testTempDirectory != null)
            // create a default profile
            // generate a fake key
            val user = User("test@rustyrazorblade.com", "us-west-2", "test", "test", "test", "test", "test", "", "")

            val context = Context(testTempDirectory.toFile())
            context.yaml.writeValue(context.userConfigFile, user)
            return context
        }
    }

    fun requireSshKey() {
        if (!File(userConfig.sshKeyPath).exists()) {
            log.error { "SSH key not found at ${userConfig.sshKeyPath}" }
            System.exit(1)
        }
    }
}
